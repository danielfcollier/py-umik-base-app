"""
Metrics Visualizer.
Reads a CSV generated by calculate_file_metrics.py (or batch_analyze.py) and
generates a professional-grade time-series plot.

This script supports dynamic subplots:
1. Level Plot: Combines dBFS, LUFS, and dBSPL on a shared dB axis.
2. Flux Plot: Displays spectral flux (onsets) on a separate axis below.

It automatically detects if absolute timestamps (ISO 8601) are present in the CSV
and formats the X-axis as "Time of Day" (HH:MM:SS) accordingly.

Author: Daniel Collier
GitHub: https://github.com/danielfcollier
Year: 2025
"""

import argparse
import logging
import os
import sys

import matplotlib.dates as mdates
import matplotlib.pyplot as plt
import pandas as pd

logging.basicConfig(level=logging.INFO, format="%(message)s", stream=sys.stdout)
logger = logging.getLogger(__name__)


def plot_csv(csv_path, save_arg=None, selected_metrics=None):
    """
    Generates and saves/displays a plot from audio metrics data.

    :param csv_path: Path to the input .csv file containing metrics.
    :param save_arg: If provided, saves the plot to this path (or auto-names it if True).
                     If None, displays the plot in a window.
    :param selected_metrics: List of metrics to include in the plot (e.g., ['dbfs', 'flux']).
    """
    logger.info(f"üìà Loading data from {csv_path}...")

    try:
        df = pd.read_csv(csv_path)
    except Exception as e:
        logger.info(f"Error reading CSV: {e}")
        sys.exit(1)

    if not selected_metrics:
        selected_metrics = ["dbfs", "lufs", "dbspl", "flux"]
    selected_metrics = [m.lower() for m in selected_metrics]

    # --- METRIC GROUPING ---
    # Group 1: Decibel/Level metrics (Y-axis is dB, typically -100 to 0 or +120)
    level_metrics = [m for m in ["dbfs", "lufs", "dbspl"] if m in selected_metrics]
    # Group 2: Index metrics (Spectral Flux is a magnitude index, not dB)
    flux_metric = "flux" in selected_metrics

    # Cleanup: Remove 'dbspl' from the list if the CSV doesn't actually contain calibration data
    if "dbspl" in level_metrics and ("dbspl" not in df.columns or not df["dbspl"].notna().any()):
        level_metrics.remove("dbspl")

    has_levels = len(level_metrics) > 0
    has_flux = flux_metric

    if not has_levels and not has_flux:
        logger.info("‚ö†Ô∏è  No valid metrics selected to plot.")
        return

    # --- DETERMINE X-AXIS ---
    # Check if 'timestamp' column exists and has valid data.
    # If yes, we use absolute time (Time of Day). If no, we use relative seconds.
    use_absolute_time = False
    if "timestamp" in df.columns and df["timestamp"].notna().all():
        try:
            df["timestamp_dt"] = pd.to_datetime(df["timestamp"])
            x_data = df["timestamp_dt"]
            use_absolute_time = True
            logger.info("üïí Detected absolute timestamps. Plotting real time.")
        except Exception:
            x_data = df["time_sec"]
    else:
        x_data = df["time_sec"]

    # --- SETUP PLOTS ---
    # Dynamic Layout: Create 2 subplots if we have both Levels and Flux, otherwise just 1.
    if has_levels and has_flux:
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 8), sharex=True)
        ax_levels, ax_flux = ax1, ax2
    else:
        fig, ax = plt.subplots(1, 1, figsize=(14, 6))
        ax_levels = ax if has_levels else None
        ax_flux = ax if has_flux else None

    fig.suptitle(f"Audio Metrics Analysis: {os.path.basename(csv_path)}", fontsize=16)

    # --- PLOT LEVELS (dB) ---
    if ax_levels:
        if "dbfs" in level_metrics:
            ax_levels.plot(x_data, df["dbfs"], label="dBFS", color="#3498db", linewidth=1, alpha=0.7)
        if "lufs" in level_metrics:
            ax_levels.plot(x_data, df["lufs"], label="LUFS", color="#2c3e50", linewidth=2)
        if "dbspl" in level_metrics:
            # dBSPL is plotted with a dashed line to distinguish it from digital levels
            ax_levels.plot(x_data, df["dbspl"], label="dBSPL", color="#e74c3c", linestyle="--")

        ax_levels.set_ylabel("Level (dB)")
        ax_levels.grid(True, which="both", linestyle="--", alpha=0.5)
        ax_levels.legend(loc="upper right")

    # --- PLOT FLUX (Onset/Event) ---
    if ax_flux:
        ax_flux.plot(x_data, df["flux"], label="Flux", color="#e67e22", linewidth=1)
        ax_flux.set_ylabel("Flux Index")
        ax_flux.grid(True, which="both", linestyle="--", alpha=0.5)
        # Fill area under flux to make spikes (events) visually obvious
        ax_flux.fill_between(x_data, df["flux"], color="#e67e22", alpha=0.3)
        ax_flux.legend(loc="upper right")

    # --- FORMAT X-AXIS ---
    target_ax = ax_flux if ax_flux else ax_levels
    if use_absolute_time:
        target_ax.set_xlabel("Time of Day")
        # Format X-axis as HH:MM:SS using Matplotlib's DateFormatter
        target_ax.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M:%S"))
        fig.autofmt_xdate()  # Rotate labels nicely to prevent overlap
    else:
        target_ax.set_xlabel("Time (seconds)")

    plt.tight_layout()

    # --- OUTPUT ---
    if save_arg is not None:
        # If save_arg is True (flag only), generate filename based on CSV name
        if isinstance(save_arg, bool) and save_arg:
            base_name = os.path.splitext(csv_path)[0]
            save_path = f"{base_name}.png"
        else:
            save_path = save_arg
        plt.savefig(save_path)
        logger.info(f"‚úÖ Plot saved to: {save_path}")
    else:
        logger.info("üñ•Ô∏è  Opening plot window...")
        plt.show()


def main():
    parser = argparse.ArgumentParser(description="Visualize audio metrics from CSV.")
    parser.add_argument("csv_file", help="Path to the .csv file")
    parser.add_argument("--save", nargs="?", const=True, default=None, help="Save plot to image.")
    parser.add_argument("--metrics", nargs="+", default=["dbfs", "lufs", "dbspl", "flux"], help="Metrics to plot.")

    args = parser.parse_args()
    plot_csv(args.csv_file, args.save, args.metrics)


if __name__ == "__main__":
    main()
