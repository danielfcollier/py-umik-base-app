"""
Metrics Visualizer.
Reads a CSV generated by the analyzer and generates a professional time-series plot.

Supports dynamic subplots for Levels (dB) and Spectral Flux.
It automatically detects if absolute timestamps (ISO 8601) are present in the CSV
and formats the X-axis as "Time of Day" (HH:MM:SS) accordingly.

Author: Daniel Collier
GitHub: https://github.com/danielfcollier
Year: 2025
"""

import argparse
import logging
import os
import sys

import pandas as pd

logging.basicConfig(level=logging.INFO, format="%(message)s", stream=sys.stdout)
logger = logging.getLogger(__name__)


class MetricsVisualizer:
    """
    Handles loading CSV data and rendering matplotlib charts.
    """

    def __init__(self, csv_path: str):
        self.csv_path = csv_path
        if not os.path.exists(csv_path):
            raise FileNotFoundError(f"CSV file not found: {csv_path}")

        logger.info(f"Loading data from {csv_path}...")
        self.df = pd.read_csv(csv_path)

    def plot(self, metrics: list[str], save_path: str | None = None):
        """
        Generates the plot based on selected metrics.
        """
        import matplotlib

        # If saving to file, force the 'Agg' backend (Headless/No GUI)
        # This prevents crashes on servers or CI environments without screens.
        if save_path:
            matplotlib.use("Agg")

        import matplotlib.dates as mdates
        import matplotlib.pyplot as plt

        metrics = [m.lower() for m in metrics]

        # 1. Filter Available Metrics
        level_metrics = [m for m in ["dbfs", "lufs", "dbspl"] if m in metrics]

        # Verify columns exist
        level_metrics = [m for m in level_metrics if m in self.df.columns]

        # Check dBSPL specifically (might be empty strings if uncalibrated)
        if "dbspl" in level_metrics:
            if not pd.to_numeric(self.df["dbspl"], errors="coerce").notna().any():
                logger.warning("dBSPL selected but column is empty. Removing from plot.")
                level_metrics.remove("dbspl")

        has_flux = "flux" in metrics and "flux" in self.df.columns
        has_levels = len(level_metrics) > 0

        if not has_levels and not has_flux:
            logger.error("No valid metrics found to plot.")
            return

        # 2. Setup Subplots
        if has_levels and has_flux:
            fig, (ax_levels, ax_flux) = plt.subplots(2, 1, figsize=(14, 8), sharex=True)
        else:
            fig, ax = plt.subplots(1, 1, figsize=(14, 6))
            ax_levels = ax if has_levels else None
            ax_flux = ax if has_flux else None

        fig.suptitle(f"Audio Analysis: {os.path.basename(self.csv_path)}", fontsize=16)

        # 3. Determine X-Axis (Time)
        x_data, is_absolute = self._get_time_axis()

        # 4. Plot Levels
        if ax_levels:
            if "dbfs" in level_metrics:
                ax_levels.plot(x_data, self.df["dbfs"], label="dBFS", color="#3498db", alpha=0.7)
            if "lufs" in level_metrics:
                ax_levels.plot(x_data, self.df["lufs"], label="LUFS", color="#2c3e50", linewidth=2)
            if "dbspl" in level_metrics:
                ax_levels.plot(x_data, self.df["dbspl"], label="dBSPL", color="#e74c3c", linestyle="--")

            ax_levels.set_ylabel("Level (dB)")
            ax_levels.grid(True, which="both", linestyle="--", alpha=0.5)
            ax_levels.legend(loc="upper right")

        # 5. Plot Flux
        if ax_flux:
            ax_flux.plot(x_data, self.df["flux"], label="Flux", color="#e67e22")
            ax_flux.fill_between(x_data, self.df["flux"], color="#e67e22", alpha=0.3)
            ax_flux.set_ylabel("Flux Index")
            ax_flux.grid(True, linestyle="--", alpha=0.5)
            ax_flux.legend(loc="upper right")

        # 6. Format X-Axis
        target_ax = ax_flux if ax_flux else ax_levels
        if is_absolute:
            target_ax.set_xlabel("Time of Day")
            target_ax.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M:%S"))
            fig.autofmt_xdate()
        else:
            target_ax.set_xlabel("Time (seconds)")

        plt.tight_layout()

        # 7. Output
        if save_path:
            # Handle boolean flag case (argparse const=True)
            if isinstance(save_path, bool):
                save_path = os.path.splitext(self.csv_path)[0] + ".png"

            plt.savefig(save_path)
            logger.info(f"‚úÖ Plot saved to: {save_path}")
        else:
            logger.info("üñ•Ô∏è  Displaying plot...")
            plt.show()

    def _get_time_axis(self):
        """Returns (x_data_series, is_absolute_bool)."""
        if "timestamp" in self.df.columns and self.df["timestamp"].notna().all():
            try:
                return pd.to_datetime(self.df["timestamp"]), True
            except Exception:
                pass
        return self.df["time_sec"], False


def main():
    parser = argparse.ArgumentParser(description="Visualize audio metrics from CSV.")
    parser.add_argument("csv_file", help="Path to analysis CSV")
    parser.add_argument("--save", nargs="?", const=True, default=None, help="Save to image instead of showing")
    parser.add_argument("--metrics", nargs="+", default=["dbfs", "lufs", "dbspl", "flux"], help="Metrics to include")

    args = parser.parse_args()

    try:
        viz = MetricsVisualizer(args.csv_file)
        viz.plot(args.metrics, args.save)
    except Exception as e:
        logger.error(f"Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
